# -*- coding: utf-8 -*-
"""edge-effects-data-branch-2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12N8_TVx8r0DmUwAV50VaL1FPxMIyBtMR

## Downloads
"""

import sys

def is_running_on_colab():
    """
    Verifica se o código está sendo executado no Google Colab.
    Retorna True se estiver no Colab, False caso contrário.
    """
    return 'google.colab' in sys.modules

# Exemplo de uso
if is_running_on_colab():
    print("Estou no Google Colab")
    # Coloque seu código específico do Colab aqui
    #!pip install osmnx

else:
    print("Estou em um ambiente local")
    # Coloque seu código específico do ambiente local aqui

"""## Imports"""

import osmnx as ox
import plotly.express as px
import networkx as nx
import numpy as np
import pandas as pd
from shapely.constructive import normalize
import requests
from io import StringIO
import seaborn as sns
import matplotlib.pyplot as plt
import time as t
import ast
import math
import plotly.graph_objects as go

"""## Constants"""

# certo
CITY = 'São Paulo'
UF = 'sp'
CENTER_POINT = -23.546, -46.634

# CITY = 'São José dos Campos'
# UF = 'sj'
# CENTER_POINT = -23.220,-45.891

# CITY =  'Rio de Janeiro'
# UF = 'rj'
# CENTER_POINT = -22.909,-43.184

# CITY =  'Barcelona'
# UF = 'ba'
# CENTER_POINT = 41.390, 2.166

# CITY =  'Manhattan'
# UF = 'ma'
# CENTER_POINT = 40.748, -73.985

# CITY = 'Brasília'
# UF = 'br'
# CENTER_POINT = -15.796,-47.891

MAX_RADIUS = 3000
RADIUS_SUBGRAPH = 2900
MEASURES = 2

# ==============================
# teste
# CENTER_POINT = -23.209,-45.850
# MAX_RADIUS = 1000
# RADIUS_SUBGRAPH = 500
# MEASURES = 2

"""## Support functions

The point-wise vulnerability (citar Gio) :

\begin{equation}
    V(i) = \frac{E(G) - E(G, i)}{E(G)}
\end{equation}

where $V(i)$ is the point-wise vulnerability of the node $i$, $E(G)$ is the global efficiency of the network, and $E(G,i)$ is the global efficiency of a new similar network, being the only diffrence is the node $i$ disconnection from the network.
"""

def vulnerability_node(graph):
    vul = {}
    similar_graph = nx.Graph(graph)
    for node in similar_graph.nodes:

        # Remotion node
        similar_graph_copy = similar_graph.copy()
        similar_graph_copy.remove_node(node)

        # getting efficency
        eff_before = nx.global_efficiency(similar_graph)
        eff_after = nx.global_efficiency(similar_graph_copy)

        vul[node] = (eff_before - eff_after)/eff_before


    graph.graph['vulnerability-node']= vul

"""
Closeness centrality measures.
"""
import functools

import networkx as nx
from networkx.exception import NetworkXError
from networkx.utils.decorators import not_implemented_for

__all__ = ["closeness_centrality", "incremental_closeness_centrality"]


def closeness_local(G, u=None, distance=None, wf_improved=True):
    if G.is_directed():
        G = G.reverse()  # create a reversed graph view

    if distance is not None:
        # use Dijkstra's algorithm with specified attribute as edge weight
        path_length = functools.partial(
            nx.single_source_dijkstra_path_length, weight=distance
        )
    else:
        path_length = nx.single_source_shortest_path_length

    if u is None:
        nodes = G.nodes
    else:
        nodes = [u]
    closeness_dict = {}
    for n in nodes:
        sp = path_length(G, n)
        totsp = sum(sp.values())
        len_G = SIZE
        _closeness_centrality = 0.0
        if totsp > 0.0 and len_G > 1:
            _closeness_centrality = (len(sp) - 1.0) / totsp
            # normalize to number of nodes-1 in connected part
            if wf_improved:
                s = (len(sp) - 1.0) / (len_G - 1)
                _closeness_centrality *= s
        closeness_dict[n] = _closeness_centrality
    if u is not None:
        return closeness_dict[u]
    return closeness_dict

def degree_local(G):
    if len(G) <= 1:
        return {n: 1 for n in G}

    s = 1.0 / (SIZE - 1.0)
    centrality = {n: d * s for n, d in G.degree()}
    return centrality

"""## Generating data"""

G = ox.graph_from_point(CENTER_POINT, dist = RADIUS_SUBGRAPH, dist_type='bbox', network_type='drive', truncate_by_edge=True)
SIZE = len(G)

def generating_data(graph):

    # Nodes attributes
    # calculate node degree centrality
    dc = degree_local(graph)
    nx.set_node_attributes(graph, values=dc, name="dc")

    # # calculate node closeness centrality
    cc = closeness_local(graph)
    nx.set_node_attributes(graph, values=cc, name="cc")

    # calculate node betweenness centrality
    bc = nx.betweenness_centrality(graph)
    nx.set_node_attributes(graph, values=bc, name="bc")

    # vulnerability per efficiency - node(simple graph)
    vulnerability_node(graph)
    nx.set_node_attributes(graph, values=graph.graph['vulnerability-node'], name='vul')

    simple_graph = nx.Graph(graph)
    sub = nx.subgraph_centrality_exp(simple_graph)
    nx.set_node_attributes(graph, values = sub, name="sub")


    # graph attributes
    # calculate efficiency
    e = nx.global_efficiency(simple_graph)
    dict_eff = {}
    for node in simple_graph:
        dict_eff[node] = e

    nx.set_node_attributes(graph, values=dict_eff, name='eff')

    return graph

# Save data for tests
def save_data(center_point, measures, size_subgraph , max_radius, uf):
    interval = (max_radius - size_subgraph)//measures;
    print(interval)

    for size in range(size_subgraph, max_radius + interval, interval):
        time_start = t.time()
        graph = ox.graph.graph_from_point(center_point, dist = size, dist_type='bbox', network_type='drive', truncate_by_edge=True)
        graph = generating_data(graph)

        time_end = t.time()
        time_code = (time_end - time_start)
        dict_time = {}
        for node in graph:
            dict_time[node] = time_code

        nx.set_node_attributes(graph, values=dict_time, name='time')


        nodes_df, edges_df = ox.utils_graph.graph_to_gdfs(graph)

        nodes_df.to_csv(f'data-nodes-com-{uf}-{size}.csv')


        print(f'size: {size}\t time: {time_code:}s')

    return nodes_df


"""## Generate data"""

# Uncomment the line below to generate your own data
nodes_df = save_data(CENTER_POINT, MEASURES-1, RADIUS_SUBGRAPH, MAX_RADIUS, UF)
