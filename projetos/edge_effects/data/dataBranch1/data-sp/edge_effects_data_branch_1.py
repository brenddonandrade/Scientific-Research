# -*- coding: utf-8 -*-
"""edge-effects-data-branch-1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-bxExubofghxA_f2nUUf_4YoYUhhfrLD

## Downloads
"""

import sys

def is_running_on_colab():
    """
    Verifica se o código está sendo executado no Google Colab.
    Retorna True se estiver no Colab, False caso contrário.
    """
    return 'google.colab' in sys.modules

# Exemplo de uso
if is_running_on_colab():
    print("Estou no Google Colab")
    # Coloque seu código específico do Colab aqui
    #!pip install osmnx

else:
    print("Estou em um ambiente local")
    # Coloque seu código específico do ambiente local aqui

"""## Imports"""

import osmnx as ox
import plotly.express as px
import networkx as nx
import numpy as np
import pandas as pd
from shapely.constructive import normalize
import requests
from io import StringIO
import seaborn as sns
import matplotlib.pyplot as plt
import time as t
import ast
import math
import plotly.graph_objects as go

"""## Constants"""

# certo
CITY = 'São Paulo'
UF = 'sp'
CENTER_POINT = -23.546, -46.634

# CITY = 'São José dos Campos'
# UF = 'sj'
# CENTER_POINT = -23.220,-45.891

# CITY =  'Rio de Janeiro'
# UF = 'rj'
# CENTER_POINT = -22.909,-43.184

# CITY =  'Barcelona'
# UF = 'ba'
# CENTER_POINT = 41.390, 2.166

# CITY =  'Manhattan'
# UF = 'ma'
# CENTER_POINT = 40.748, -73.985

# CITY = 'Brasília'
# UF = 'br'
# CENTER_POINT = -15.796,-47.891

MAX_RADIUS = 2800
RADIUS_SUBGRAPH = 2700
MEASURES = 2

# ==============================
# teste
# CENTER_POINT = -23.209,-45.850
# MAX_RADIUS = 1000
# RADIUS_SUBGRAPH = 500
# MEASURES = 2

"""## Support functions

The point-wise vulnerability (citar Gio) :

\begin{equation}
    V(i) = \frac{E(G) - E(G, i)}{E(G)}
\end{equation}

where $V(i)$ is the point-wise vulnerability of the node $i$, $E(G)$ is the global efficiency of the network, and $E(G,i)$ is the global efficiency of a new similar network, being the only diffrence is the node $i$ disconnection from the network.
"""

def vulnerability_node(graph):
    vul = {}
    similar_graph = nx.Graph(graph)
    for node in similar_graph.nodes:

        # Remotion node
        similar_graph_copy = similar_graph.copy()
        similar_graph_copy.remove_node(node)

        # getting efficency
        eff_before = nx.global_efficiency(similar_graph)
        eff_after = nx.global_efficiency(similar_graph_copy)

        vul[node] = (eff_before - eff_after)/eff_before


    graph.graph['vulnerability-node']= vul

"""## Generating data"""

def generating_data(graph):

    # Nodes attributes
    # calculate node degree centrality
    dc = nx.degree_centrality(graph)
    nx.set_node_attributes(graph, values=dc, name="dc")

    # calculate node closeness centrality
    cc = nx.closeness_centrality(graph)
    nx.set_node_attributes(graph, values=cc, name="cc")

    # calculate node betweenness centrality
    bc = nx.betweenness_centrality(graph)
    nx.set_node_attributes(graph, values=bc, name="bc")

    # vulnerability per efficiency - node(simple graph)
    vulnerability_node(graph)
    nx.set_node_attributes(graph, values=graph.graph['vulnerability-node'], name='vul')


    # graph attributes
    simple_graph = nx.Graph(graph)
    # calculate efficiency
    e = nx.global_efficiency(simple_graph)
    dict_eff = {}
    for node in simple_graph:
        dict_eff[node] = e

    nx.set_node_attributes(graph, values=dict_eff, name='eff')

    return graph

# Save data for tests
def save_data(center_point, measures, size_subgraph , max_radius, uf):
    interval = (max_radius - size_subgraph)//measures;
    print(interval)

    for size in range(size_subgraph, max_radius + interval, interval):
        time_start = t.time()
        graph = ox.graph.graph_from_point(center_point, dist = size, dist_type='bbox', network_type='drive', truncate_by_edge=True)
        graph = generating_data(graph)

        nodes_df, edges_df = ox.utils_graph.graph_to_gdfs(graph)
        nodes_df.to_csv(f'data-nodes-com-{uf}-{size}.csv')

        time_end = t.time()

        time_code = (time_end - time_start)
        print(f'size: {size}\t time: {time_code:}s')

    return nodes_df

"""## Generate data"""

# Uncomment the line below to generate your own data
nodes_df = save_data(CENTER_POINT, MEASURES-1, RADIUS_SUBGRAPH, MAX_RADIUS, UF)
