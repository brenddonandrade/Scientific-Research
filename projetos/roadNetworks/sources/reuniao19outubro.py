# -*- coding: utf-8 -*-
"""reuniao19outubro.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cm4nCYW79FfvS0TFlHq_9Zvtcc3k6GYy

# How far can communicability go?
Partindo de uma região com N1 nós ({0, 1, 2, ... , N1-1}) vamos crescer as regiões. Analisar as métricas:
- Grau (degree)
- Caminho mínimo médio (closeness)
- Eficiência (efficience)
- Vulnerabilidade por eficiência
- Intermediações (betweenness)

Como a média delas variam com o aumento da rede?

## Perguntas
- Como saber quantos passos considerar da rede? Exemplo, para a cidade com maior densidade foi necessário 20 passos. Então colocar o 20 como padrão?

## Ideias
- Fazer um gráfico de como aumenta o custo com o tempo de cada um das medidas de acordo com o aumento da rede
- Como fazer?

## Afazeres
- Criar um dataframe para:
    - Node
    - Edge
    - Global attribute
    - Create graphics
    - Fazer um dataframe pra node, edge
"""

!pip install -q numpy==1.23.5
!pip install -q networkx==3.1
!pip install -q pandas==1.5.3
!pip install -q plotly==5.12.0
!pip install -q osmnx==1.6.0

!pip install osmnx

import osmnx as ox
import networkx as nx
import numpy as np
import pandas as pd
from shapely.constructive import normalize
import requests
from io import StringIO
import seaborn as sns
import matplotlib.pyplot as plt
import time as t

"""## Constants"""

CENTER_POINT = -23.209,-45.850
MAX_RADIUS = 2000
RADIUS_SUBGRAPH = 1500
MEASURES = 6
# MAX_RADIUS

"""## Support functions"""

def vulnerability(graph):
    vul = {}
    simple_graph = nx.Graph(graph)
    for node in simple_graph.nodes:

        # Remotion node
        simple_graph_copy = simple_graph.copy()
        simple_graph_copy.remove_node(node)

        # getting efficency
        eff_before = nx.global_efficiency(simple_graph)
        eff_after = nx.global_efficiency(simple_graph_copy)

        vul[node] = eff_before/eff_after


    graph.graph['vulnerability']= vul

def communicability_nx(graph):
    # transforming into a simple graph to calculate communicability
    simple_graph = nx.Graph(graph)
    com = nx.communicability_exp(simple_graph)

    return com

def create_data_frame(graph):
    # Save data

    nodes_data = list(graph.nodes(data=True))
    edges_data = list(graph.edges(data=True))

    nodes_df = pd.DataFrame(nodes_data, columns=['Nodes', 'Attributes'])

"""## Getting network"""

G = ox.graph.graph_from_point(CENTER_POINT, dist=MAX_RADIUS, dist_type='bbox', network_type='drive', simplify=True)

"""## Generating data"""

def generating_data(graph):

    # Nodes attributes
    # calculate node degree centrality
    dc = nx.degree_centrality(graph)
    nx.set_node_attributes(graph, values=dc, name="dc")



    # calculate node closeness centrality
    cc = nx.closeness_centrality(graph)
    nx.set_node_attributes(graph, values=cc, name="cc")

    # calculate node betweenness centrality
    bc = nx.betweenness_centrality(graph)
    nx.set_node_attributes(graph, values=bc, name="nbc")


    # # Edges attributes
    # # calculate edge betweenness centrality
    bce = nx.edge_betweenness_centrality(graph)
    nx.set_edge_attributes(graph, values=bce, name="ebc")


    # Measures of the Simple graph
    # calculete communicability of the nodes
    # Note that communicability is defined for a simple graph (our graph is not
    # of this type)
    simple_graph = nx.Graph(graph)
    com = nx.communicability_exp(simple_graph)
    dict_com = {}
    for node_p, nodes_values in com.items():
        let_com = 0
        for node_q, com_value in nodes_values.items():
            let_com = let_com + com_value

        dict_com[node_p] = let_com
    nx.set_node_attributes(graph, values=dict_com, name="com")


    # # graph attributes
    # # calculate efficiency
    simple_graph = nx.Graph(graph)
    e = nx.global_efficiency(simple_graph)
    graph.graph['ef'] = e

    # vulnerability per efficiency
    vulnerability(graph)



    return graph

def create_data_frame(graph):
    # Save data
    # nodes
    nodes_data = list(graph.nodes(data=True))
    nodes_dict = {}


    # edges
    edges_data = list(graph.edges(data=True))
    edges_dict = {}


    for i in range(len(list(nodes_data))):
        for node, data in nodes_data:
            data['node'] = int(node)
            nodes_dict[i] = data

    nodes_df = pd.DataFrame(nodes_dict)
    nodes_df = nodes_df.transpose()


    for i in range(len(list(edges_data))):
        for u, v,  data in edges_data:
            data['edge'] = (u ,v)
            edges_dict[i] = data

    edges_df = pd.DataFrame(edges_dict)
    edges_df = edges_df.transpose()


    return nodes_df, edges_df

# Save data for tests
def save_data(center_point, measures, size_subgraph , max_radius):
    interval = (max_radius - size_subgraph)//measures;

    for size in range(size_subgraph, max_radius + interval, interval):
        time_start = t.time()
        graph = ox.graph.graph_from_point(center_point, dist = size, dist_type='bbox', network_type='drive', simplify=True)
        graph = generating_data(graph)

        nodes_df, edges_df = ox.utils_graph.graph_to_gdfs(graph)
        nodes_df.to_csv(f'data-nodes-{size}.csv')
        edges_df.to_csv(f'data-edges-{size}.csv')

        time_end = t.time()

        time_code = (time_end - time_start)
        print(f'size: {size}\t time: {time_code:}s')

    return nodes_df, edges_df

"""## Steps to plots data comming from github"""

# Getting file
def getting_file_github(url):
    '''
    Parameters
    ----------
    url: raw url of the file
    '''
    response = requests.get(url)

    # Check if you can get the file
    if response.status_code == 200:
        csv_data = response.text
        csv_buffer = StringIO(csv_data)
        df = pd.read_csv(csv_buffer, index_col=0)
    else:
        print("Falha ao obter o arquivo CSV do GitHub. Código de status:", response.status_code)

    return df

# Uncomment the line below to generate your own data
nodes_df, egdes_df = save_data(CENTER_POINT, MEASURES-1, RADIUS_SUBGRAPH, MAX_RADIUS)



# # Reading csv
# node_df_1500 = pd.read_csv('data-nodes-1500.csv')
# node_df_1600 = pd.read_csv('data-nodes-1600.csv')
# node_df_1700 = pd.read_csv('data-nodes-1700.csv')
# node_df_1800 = pd.read_csv('data-nodes-1800.csv')
# node_df_1900 = pd.read_csv('data-nodes-1900.csv')
# node_df_2000 = pd.read_csv('data-nodes-2000.csv')



# Uncomment the lines below to get data from the github repository
# Nodes
# node_df_1500 = getting_file_github('https://raw.githubusercontent.com/brenddonandrade/Scientific-Research/main/projetos/roadNetworks/data/data-nodes-1500.csv')
# node_df_2000 = getting_file_github('https://raw.githubusercontent.com/brenddonandrade/Scientific-Research/main/projetos/roadNetworks/data/data-nodes-2000.csv')
# node_df_2500 = getting_file_github('https://raw.githubusercontent.com/brenddonandrade/Scientific-Research/main/projetos/roadNetworks/data/data-nodes-2500.csv')
# node_df_3000 = getting_file_github('https://raw.githubusercontent.com/brenddonandrade/Scientific-Research/main/projetos/roadNetworks/data/data-nodes-3000.csv')

# # Edges
# edge_df_1500 = getting_file_github('https://raw.githubusercontent.com/brenddonandrade/Scientific-Research/main/projetos/roadNetworks/data/data-edges-1500.csv')
# edge_df_2000 = getting_file_github('https://raw.githubusercontent.com/brenddonandrade/Scientific-Research/main/projetos/roadNetworks/data/data-edges-2000.csv')
# edge_df_2500 = getting_file_github('https://raw.githubusercontent.com/brenddonandrade/Scientific-Research/main/projetos/roadNetworks/data/data-edges-2500.csv')
# edge_df_3000 = getting_file_github('https://raw.githubusercontent.com/brenddonandrade/Scientific-Research/main/projetos/roadNetworks/data/data-edges-3000.csv')

# node_df_375 = pd.read_csv('data-nodes-375.csv')
# node_df_750 = pd.read_csv('data-nodes-750.csv')
# node_df_1125 = pd.read_csv('data-nodes-1125.csv')
# node_df_1500 = pd.read_csv('data-nodes-1500.csv')



# check change in node
def change_measure_node_github(df_1, df_2, measure):

    # Vou criar DataFrames de exemplo para demonstração
    # Combine os DataFrames em um único DataFrame
    df_combined = pd.concat([df_1, df_2], keys=['DataFrame1', 'DataFrame2'])

    print(df_combined)
    # # Crie o scatter plot
    sns.scatterplot(data=df_combined, x=measure, y=measure, hue=df_combined.index.get_level_values(0))
    plt.xlabel('Dados do DataFrame 1')
    plt.ylabel('Dados do DataFrame 2')
    plt.title('Scatter Plot entre DataFrames')
    plt.show()


    # return df_diff
# Agora 'common_rows' contém a diferença nas colunas 'coluna1' e 'coluna2' para as linhas comuns

def plot_matrix(dfs, measure):

    # Combine todos os DataFrames em um único DataFrame
    i = 1500
    dfs_subset = pd.DataFrame()
    for df in dfs:
        dfs_subset[f'node-{i}'] = df[measure]
        i = i + 100

    # combined_df = pd.concat(dfs_subset)


    # # Crie o scatter plot
    # sns.scatterplot(data=df_combined, x=measure, y=measure, hue=df_combined.index.get_level_values(0))
    # plt.xlabel('Dados do DataFrame 1')
    # plt.ylabel('Dados do DataFrame 2')
    # plt.title('Scatter Plot entre DataFrames')
    # plt.show()

    # i = 1
    # # for df in combined_df:
    # #     df['DataFrame'] = f"DataFrame-{i}"
    # #     i = i+1
    # combined_df[0]['DataFrame'] = 'DataFrame 1'
    # combined_df[1]['DataFrame'] = 'DataFrame 2'
    # combined_df[2]['DataFrame'] = 'DataFrame 3'
    # combined_df[3]['DataFrame'] = 'DataFrame 4'

    # Crie uma matriz de gráficos de dispersão
    sns.set(style="ticks")
    sns.pairplot(dfs_subset)
    plt.suptitle(measure)
    plt.show()

# dfs = [node_df_1500, node_df_1600, node_df_1700, node_df_1800, node_df_1900, node_df_2000]
# plot_matrix(dfs, 'com')

# node_df_1500

# # work with date
# def work_with_data_github(df, name_index = None):
#     df_transpose = df.T

#     return df_transpose

# df = work_with_data_github(df)
# df.columns= ['Nodes', 'Edges', 'Efficiency']

# change_measure_node_github(df['Nodes'])

# df

"""## Steps to plots data comming from your generate"""

# check change in node
def change_measure_node(series):

    index = [i for i in range(200, 1200, 200)]

    let_dict_before = {}
    let_dict_after = {}

    serie_subgraph = series[400].copy()

    for key_1 in serie_subgraph:

        if key_1 == 'node':
            nodes_subgraph = list(serie_subgraph[key_1].values())

        if  (key_1 == 'nbc') or( key_1 == 'com') or (key_1 == 'dc')  or (key_1 == 'cc'):
            let_dict_before[key_1] = np.mean(list(serie_subgraph[key_1].values()))

    print(let_dict_before)
    print(nodes_subgraph)

    for serie in series:
        # if serie == serie_subgraph:
        #     pass

        for key, value in serie['node'].items():
            if value in nodes_subgraph:
                print(key, value)

        # for key, value in serie.items():
        #     print(key, value)
        # print(type(serie))
        # print(len(serie))
        # print(serie)

# df_save = df.copy()

# df = df_save.copy()

# work with date
def work_with_data(df, name_index = None):
    df_transpose = df.T

    return df_transpose

# df = work_with_data(df)
# df.columns = ['Nodes', 'Edges', 'Efficiency']

# df

# change_measure_node(df['Nodes'])

def create_subgraph(graph, central_node, radius):
    '''
    Parameters
    ----------
    graph: MultiDiGraph
        a graph stores nodes and edges

    central_node: node of the graph
        the center node where initiate path

    radius: int
        size of the path

    Create a subgraph from the given graph with
    central node or nodes that are at a distance smaller
    than the requested radius.
    '''
    subgraph = nx.ego_graph(G, central_node, radius=radius)
    return subgraph

# subgraph = create_subgraph(G, 1453990694, 10)

def emphasis(graph, item):

    if graph.has_node(item):

        # Especifique o nó que você deseja destacar
        node_to_highlight = item  # Substitua pelo ID do nó desejado

        # Crie uma lista de cores para os nós
        node_colors = ['r' if node == node_to_highlight else 'b' for node in graph.nodes()]

        # Plote o gráfico com a sobreposição do nó destacado
        ox.plot_graph(ox.project_graph(graph), node_color=node_colors, node_size=30, node_zorder=3, edge_color='gray', bgcolor='w')
    elif type((1,2)) == type(item):
        u, v = item
        if graph.has_edge(u, v):
            highlighted_edge = item # Substitua pelos IDs reais dos nós
            # Crie um dicionário de estilos para as arestas
            edge_colors = ['b' if e != highlighted_edge else 'r' for e in graph.edges(data=False)]

            # Plote o grafo com as arestas destacadas
            ox.plot_graph(ox.project_graph(graph), edge_color=edge_colors, node_color='gray', node_size=30, node_zorder=3, bgcolor='w')

    else:
        print(f'ERROR! The {item} is not a node or edge')

# emphasis(subgraph, (1453990700, 1453990695))

# subgraph.edges(